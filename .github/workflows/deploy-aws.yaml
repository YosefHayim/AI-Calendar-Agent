name: Deploy BE to AWS ECS

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
  ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
  ECS_SERVICE: ${{ vars.ECS_SERVICE }}
  CONTAINER_NAME: ${{ vars.CONTAINER_NAME }}
  TASK_DEFINITION_PATH: ${{ vars.TASK_DEFINITION_PATH }}
  HEALTHCHECK_PATH: ${{ vars.HEALTHCHECK_PATH || '/' }}
  CURL_TIMEOUT_SECS: "300"

jobs:
  test:
    name: Run Tests & Check Coverage
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test -- --coverage --coverageReporters=text-summary > coverage.txt

      - name: Extract coverage percentage
        id: coverage
        run: |
          cat coverage.txt
          TOTAL=$(grep -Po 'All files[^|]*\|\s*\K[0-9]+' coverage.txt | head -1)
          echo "coverage=$TOTAL" >> $GITHUB_OUTPUT

      - name: Fail if coverage < 95%
        run: |
          if [ ${{ steps.coverage.outputs.coverage }} -lt 95 ]; then
            echo "❌ Coverage is ${{ steps.coverage.outputs.coverage }}%, required ≥95%"
            exit 1
          else
            echo "✅ Coverage is ${{ steps.coverage.outputs.coverage }}%, proceeding to deploy"
          fi

  deploy:
    name: Build, Push, Deploy
    runs-on: ubuntu-latest
    needs: test
    if: success() # only run if test job succeeded
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
        if: ${{ secrets.AWS_IAM_ROLE_ARN != '' }}

      - name: Configure AWS credentials (access keys fallback)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
        if: ${{ secrets.AWS_IAM_ROLE_ARN == '' }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Compute image tag
        id: meta
        run: |
          SHA_TAG=${GITHUB_SHA::12}
          echo "sha_tag=$SHA_TAG" >> "$GITHUB_OUTPUT"
          echo "image=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:$SHA_TAG" >> "$GITHUB_OUTPUT"

      - name: Build and push image
        run: |
          docker build -t "${{ steps.meta.outputs.image }}" .
          docker push "${{ steps.meta.outputs.image }}"

      - name: Render task definition with new image
        id: render
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ${{ env.TASK_DEFINITION_PATH }}
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ steps.meta.outputs.image }}

      - name: Deploy ECS task definition
        id: deploy
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Resolve ALB DNS from ECS service
        id: alb
        shell: bash
        run: |
          TG_ARN=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)

          LB_ARN=$(aws elbv2 describe-target-groups \
            --target-group-arns "$TG_ARN" \
            --query 'TargetGroups[0].LoadBalancerArns[0]' \
            --output text)

          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns "$LB_ARN" \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          HTTPS_URL="https://${ALB_DNS}"
          HTTP_URL="http://${ALB_DNS}"

          echo "alb_dns=$ALB_DNS" >> "$GITHUB_OUTPUT"
          echo "https_url=$HTTPS_URL" >> "$GITHUB_OUTPUT"
          echo "http_url=$HTTP_URL" >> "$GITHUB_OUTPUT"

      - name: Smoke check
        id: smoke
        shell: bash
        env:
          HTTPS_URL: ${{ steps.alb.outputs.https_url }}
          HTTP_URL: ${{ steps.alb.outputs.http_url }}
          PATH_TO_CHECK: ${{ env.HEALTHCHECK_PATH }}
          TIMEOUT: ${{ env.CURL_TIMEOUT_SECS }}
        run: |
          set -euo pipefail
          end=$((SECONDS + TIMEOUT))
          status=0
          url=""
          while (( SECONDS < end )); do
            for candidate in "$HTTPS_URL" "$HTTP_URL"; do
              if curl -skSf "${candidate}${PATH_TO_CHECK}" -o /dev/null; then
                url="$candidate"
                status=0
                break 2
              fi
            done
            sleep 5
          done || status=$?
          if [[ $status -ne 0 || -z "$url" ]]; then
            echo "Service did not become healthy within ${TIMEOUT}s" >&2
            echo "live_url=" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          echo "live_url=$url" >> "$GITHUB_OUTPUT"

      - name: Output live URL
        if: always()
        run: |
          URL="${{ steps.smoke.outputs.live_url }}"
          {
            echo "# Deployment result"
            if [[ -n "$URL" ]]; then
              echo "Live URL: $URL"
            else
              echo "ALB URL: https://${{ steps.alb.outputs.alb_dns }}"
            fi
            echo "Image: ${{ steps.meta.outputs.image }}"
            echo "Cluster: ${{ env.ECS_CLUSTER }}"
            echo "Service: ${{ env.ECS_SERVICE }}"
            echo "Commit: $GITHUB_SHA"
          } | tee -a "$GITHUB_STEP_SUMMARY"
